name: user-server-integrated

on:
  workflow_run:
    workflows: ["user-server-build", "user-server-test", "user-server-quality-gate"]
    types:
      - completed
  workflow_dispatch:

permissions:
  contents: read
  actions: read
  pull-requests: write

jobs:
  wait-and-verify:
    name: Verify All Pipelines Succeeded
    runs-on: ubuntu-latest
    steps:
      - name: Check all workflow runs (Build, Test, Quality Gate)
        uses: actions/github-script@v6
        with:
          script: |
            // Ensure we only consider runs for the same commit (head_sha) to avoid races
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const requiredWorkflows = ['user-server-build', 'user-server-test', 'user-server-quality-gate'];
            const headSha = context.payload && context.payload.workflow_run && context.payload.workflow_run.head_sha ? context.payload.workflow_run.head_sha : process.env.GITHUB_SHA;
            let failures = [];

            // Helper: sleep
            const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

            for (const wfName of requiredWorkflows) {
              let foundAndChecked = false;
              // retry loop: wait up to ~60s total (12 * 5s) for other workflows to appear/complete
              for (let attempt = 0; attempt < 12; attempt++) {
                const runs = await github.rest.actions.listWorkflowRunsForRepo({ owner, repo, per_page: 100 });
                const run = runs.data.workflow_runs.find(r => r.name === wfName && r.head_sha === headSha);

                if (!run) {
                  console.log(`${wfName}: no run found for head ${headSha} (attempt ${attempt + 1}/12)`);
                  await sleep(5000);
                  continue;
                }

                if (run.status !== 'completed') {
                  console.log(`${wfName}: run found but status=${run.status} (attempt ${attempt + 1}/12), waiting`);
                  await sleep(5000);
                  continue;
                }

                if (run.conclusion !== 'success') {
                  failures.push(`${wfName}: failed (conclusion=${run.conclusion})`);
                } else {
                  console.log(`✓ ${wfName}: SUCCESS (head ${headSha})`);
                }

                foundAndChecked = true;
                break;
              }

              if (!foundAndChecked) {
                failures.push(`${wfName}: no completed run found for head ${headSha} after retries`);
              }
            }

            if (failures.length > 0) {
              console.error('❌ Pipeline verification failed:');
              failures.forEach(f => console.error(`  - ${f}`));
              throw new Error('Integrated check failed: ' + failures.join('; '));
            }

            console.log('✓ All required pipelines (build, test, quality-gate) completed successfully for head ' + headSha + '!');

      - name: Remove workflow trigger labels on success
        if: success()
        uses: actions/github-script@v6
        env:
          LABEL_BOT_TOKEN: ${{ secrets.LABEL_BOT_TOKEN }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const labelsToRemove = ['extra:build-needed', 'extra:test-needed', 'extra:quality-needed', 'ci-build', 'ci-test', 'ci-quality'];

            // Prefer a dedicated bot token if provided, otherwise fall back to the Actions token
            const token = process.env.LABEL_BOT_TOKEN || process.env.GITHUB_TOKEN;
            const octokit = github.getOctokit(token);

            // Use the commit SHA that triggered the workflow_run (robust across forks)
            const headSha = context.payload && context.payload.workflow_run && context.payload.workflow_run.head_sha ? context.payload.workflow_run.head_sha : process.env.GITHUB_SHA;

            // Find PRs associated with this commit
            const prsResp = await octokit.rest.repos.listPullRequestsAssociatedWithCommit({ owner, repo, commit_sha: headSha });
            if (!prsResp || !prsResp.data || prsResp.data.length === 0) {
              console.log('No open PR found for commit', headSha, '— skipping label removal');
              return;
            }

            // If multiple PRs, operate on the first (typical case: single PR per branch)
            const pr = prsResp.data[0];
            const prNumber = pr.number;

            // Remove labels using the chosen token (bot or actions)
            for (const label of labelsToRemove) {
              try {
                // Check if label present on PR
                const labelsResp = await octokit.rest.issues.listLabelsOnIssue({ owner, repo, issue_number: prNumber });
                const present = labelsResp.data.find(l => l.name === label);
                if (present) {
                  await octokit.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: label });
                  console.log(`✓ Removed label: ${label}`);
                }
              } catch (err) {
                console.log(`Label ${label} not present or error removing: ${err.message}`);
              }
            }

